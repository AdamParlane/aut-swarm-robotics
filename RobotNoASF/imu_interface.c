/*	twi_driver.c
*	TWI read and write functions that are compatible with the IMU's driver software
*	Also includes a routine to setup the master clock on the SAM4SD32C for 100MHz, driven by PLLA
*	and an external 12MHz crystal oscillator
*	
*	by Matthew Witt
*	28/04/2017
*/

#include <tgmath.h>
#include "sam.h"
#include "imu_interface.h"
#include "IMU-DMP/inv_mpu_dmp_motion_driver_CUSTOM.h"
#include "IMU-DMP/inv_mpu_CUSTOM.h"
#include "IMU-DMP/mpu9250.h"

/* IMU Variables */
short gyro[3], accel[3], sensors;
unsigned char more;
unsigned long sensor_timestamp;
euler_packet_t eulerAngle;
euler_packet_t *ptEulerAngle = &eulerAngle;
long quat[4];
long *ptQuat = &quat[0];

uint32_t systemTimestamp = 0;
uint32_t blinker = 0;
uint32_t check_IMU_FIFO = 0;

//Initialise the IMU, robotsetup MUST be run first
void init_imu(void)
{
	unsigned char accel_fsr;
	unsigned short gyro_rate, gyro_fsr;
	int result =0;
	
	//Orientation correction matrix for the IMU
	static signed char gyro_orientation[9] =
	{	-1,	 0,	 0,
		0,	-1,	 0,
		0,	 0,	 1
	};

	//GPIO Setup
	//We want to make an LED blink to test the timer
	//PMC is not required for such basic use of the GPIO
	REG_PIOA_PER |= PIO_PA27;										//Enable PA_27 (LED)
	REG_PIOA_OER |= PIO_PA27;										//Set PA_27 for output
	
	//Initialise the IMU's driver	
	result += mpu_init(0);											// Initialise the MPU with no interrupts
	result += mpu_set_sensors(INV_XYZ_GYRO | INV_XYZ_ACCEL | INV_XYZ_COMPASS);// Wake up all sensors
	//result += mpu_configure_fifo(INV_XYZ_GYRO | INV_XYZ_ACCEL);	// Push xyz gyro and xyz accel data to the FIFO
	result += mpu_set_sample_rate(200);								// Set 200Hz sample rate
	result += mpu_set_compass_sample_rate(100);						// Set 100Hz compass sample rate (max)
	
	/* Read back configuration in case it was set improperly. */
	result += mpu_get_sample_rate(&gyro_rate);
	result += mpu_get_gyro_fsr(&gyro_fsr);
	result += mpu_get_accel_fsr(&accel_fsr);
	
	result += dmp_load_motion_driver_firmware();					// Load the DMP firmware
	result += dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));
	//result += dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT | DMP_FEATURE_SEND_RAW_ACCEL | DMP_FEATURE_SEND_CAL_GYRO | DMP_FEATURE_GYRO_CAL);
	result += dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT);
	result += dmp_set_fifo_rate(200);								//200Hz update rate from the FIFO
	result += mpu_set_dmp_state(1);
}

unsigned short inv_orientation_matrix_to_scalar(const signed char *mtx)
{
    unsigned short scalar;

    /*
       XYZ  010_001_000 Identity Matrix
       XZY  001_010_000
       YXZ  010_000_001
       YZX  000_010_001
       ZXY  001_000_010
       ZYX  000_001_010
     */

    scalar = inv_row_2_scale(mtx);
    scalar |= inv_row_2_scale(mtx + 3) << 3;
    scalar |= inv_row_2_scale(mtx + 6) << 6;

    return scalar;
}

unsigned short inv_row_2_scale(const signed char *row)
{
	unsigned short b;

	if (row[0] > 0)
	b = 0;
	else if (row[0] < 0)
	b = 4;
	else if (row[1] > 0)
	b = 1;
	else if (row[1] < 0)
	b = 5;
	else if (row[2] > 0)
	b = 2;
	else if (row[2] < 0)
	b = 6;
	else
	b = 7;      // error
	return b;
}

//Convert Quaternion numbers from the IMU to Euler rotational angles
void GetEulerAngles(long *ptQuat, euler_packet_t *eulerAngle)
{
	double w = ptQuat[3];
	double x = ptQuat[0];
	double y = ptQuat[1];
	double z = ptQuat[2];
	double sqw = w*w;
	double sqx = x*x;
	double sqy = y*y;
	double sqz = z*z;
	double unit = sqx + sqy + sqz + sqw; // if normalised is one, otherwise is correction factor
	double test = x*y + z*w;
	if (test > 0.499*unit) { // singularity at north pole
		eulerAngle->pitch = 2 * atan2(x,w);
		eulerAngle->yaw = M_PI/2;
		eulerAngle->roll = 0;
		return;
	}
	if (test < -0.499*unit) { // singularity at south pole
		eulerAngle->pitch = -2 * atan2(x,w);
		eulerAngle->yaw = M_PI/2;
		eulerAngle->roll = 0;
		return;
	}
	eulerAngle->pitch = (atan2(2*y*w-2*x*z , sqx - sqy - sqz + sqw))*180/M_PI;
	eulerAngle->yaw = (asin(2*test/unit))*180/M_PI;
	eulerAngle->roll = (atan2(2*x*w-2*y*z , -sqx + sqy - sqz + sqw))*180/M_PI;
}

//Reads the system uptime count generated by Timer0
int get_ms(uint32_t *timestamp)
{
	if(!timestamp)
		return 1;	
	*timestamp = systemTimestamp;
	return 0;
}

//Wait for period_ms seconds
int delay_ms(uint32_t period_ms)
{
	uint32_t startTime = systemTimestamp;

	while(systemTimestamp < (startTime + period_ms))
	{

	}
	return 0;
}

//twi write function that has parameters compatible with the IMU's drivers
char twi_write_imu (unsigned char slave_addr, unsigned char reg_addr, unsigned char length, unsigned char const *data)
{
	//note txcomp MUST = 1 before writing
	REG_TWI2_CR |= TWI_CR_MSEN | TWI_CR_SVDIS;	//Enable master mode
	REG_TWI2_MMR
		=	TWI_MMR_DADR(slave_addr)		//Slave device address
		|	TWI_MMR_IADRSZ_1_BYTE;				//Register address byte length (0-3)
	REG_TWI2_IADR = reg_addr;					//set up address to write to

	if(length == 1)
	{
		REG_TWI2_THR = data[0];						//set up data to transmit
		REG_TWI2_CR = TWI_CR_STOP;					// Send a stop bit
		while(!IMU_TXRDY);								//while Transmit Holding Register not ready. wait.
	} else {
		for(unsigned char b = 0; b < length; b++)	//Send data bit by bit until data length is reached
		{
			REG_TWI2_THR = data[b];					//set up data to transmit
			while(!IMU_TXRDY);							//while Transmit Holding Register not ready. wait.
		}
	
		REG_TWI2_CR = TWI_CR_STOP;					// Send a stop bit
	}
	while(!IMU_TXCOMP);								//while transmit not complete. wait.
	return 0;
}

//twi read function that has parameters compatible with the IMU's drivers
char twi_read_imu(unsigned char slave_addr, unsigned char reg_addr, unsigned char length, unsigned char *data)
{
	REG_TWI2_CR |= TWI_CR_MSEN | TWI_CR_SVDIS;	//Enable master mode
	REG_TWI2_MMR
		=	TWI_MMR_DADR(slave_addr)		//Slave device address
		|	(TWI_MMR_MREAD)						//Set to read from register
		|	TWI_MMR_IADRSZ_1_BYTE;				//Register addr byte length (0-3)
	REG_TWI2_IADR = reg_addr;					//set up address to read from
	
	if (length == 1)							//If only ready one byte, then START and STOP bits need to be set at the same time
	{
		REG_TWI2_CR
			=	TWI_CR_START
			|	TWI_CR_STOP;					//Send a START and STOP condition as required (single byte read)	
		while(!IMU_RXRDY);							//while Receive Holding Register not ready. wait.
		data[0] = REG_TWI2_RHR;					//store data received		
		while(!IMU_TXCOMP);							//while transmit not complete. wait.
		return 0;
	} else {
		REG_TWI2_CR =	TWI_CR_START;			//Send start bit
		for(unsigned char b = 0; b < length; b++)
		{
			while(!IMU_RXRDY);
			data[b] = REG_TWI2_RHR;
			if(b == length-2)
				REG_TWI2_CR =	TWI_CR_STOP;	//Send stop on reception of 2nd to last byte
		}
		while(!IMU_TXCOMP);							//while transmit not complete. wait.
	}
	return 0;
}

//Timer0: systemTimestamp is a counter that increments once every ms. It is used for timing in the DMP driver
//This interrupt is also currently attempting to read the IMUs FIFO buffer at 200Hz
void TC0_Handler()
{
	//The interrupt handler for timer counter 0
	//Triggers every 1ms
	if(REG_TC0_SR0 & TC_SR_CPCS)									//If RC compare flag
	{
		systemTimestamp++;
		if(systemTimestamp >= (blinker + 1000))						//Blink LED so we can see system is active
		{
			blinker = systemTimestamp;
			if(REG_PIOA_ODSR & LED1) REG_PIOA_CODR |= LED1; else REG_PIOA_SODR |= LED1;
		}
		if(systemTimestamp >= (check_IMU_FIFO + 5))						//Read IMUs FIFO every 5ms
		{
			check_IMU_FIFO = systemTimestamp;
			int returnVal = dmp_read_fifo(gyro, accel, ptQuat, &sensor_timestamp, &sensors, &more);	// Read the FIFO
		}
	}
}


